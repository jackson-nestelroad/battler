{
  "stench": {
    "name": "Stench",
    "flags": [],
    "effect": {
      "callbacks": {
        "on_use_move": {
          "priority": -1,
          "program": [
            "if $move.category == status:",
            ["return"],
            "foreach $secondary in $move.secondary_effects:",
            [
              "if $secondary.target.is_defined and $secondary.target.volatile_status == flinch:",
              ["return"]
            ],
            "$added_secondary = func_call(secondary_hit_effect)",
            "$added_secondary.chance = 1/10",
            "$added_secondary.target = func_call(hit_effect)",
            "$added_secondary.target.volatile_status = flinch",
            "add_secondary_effect_to_move: $move $added_secondary"
          ]
        }
      }
    }
  },
  "drizzle": {
    "name": "Drizzle",
    "flags": [],
    "effect": {
      "callbacks": {
        "on_start": ["set_weather: rainweather use_target_as_source"]
      }
    }
  },
  "speedboost": {
    "name": "Speed Boost",
    "flags": [],
    "effect": {
      "callbacks": {
        "on_residual": [
          "if $target.active_turns > 0:",
          ["boost: $target 'spe:1'"]
        ]
      }
    }
  },
  "battlearmor": {
    "name": "Battle Armor",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "on_critical_hit": ["return false"]
      }
    }
  },
  "sturdy": {
    "name": "Sturdy",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "on_try_hit": [
          "if $move.ohko:",
          ["log_immune: $target from_effect", "return stop"]
        ],
        "on_damage": {
          "priority": -100,
          "program": [
            "if $target.hp == $target.max_hp and $damage > $target.hp and $effect.is_move:",
            ["log_activate: with_target", "return $target.hp - 1"]
          ]
        }
      }
    }
  },
  "damp": {
    "name": "Damp",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "on_any_try_move": [
          "if [explosion, mindblown, mistyexplosion, selfdestruct] has $move.id:",
          [
            "log_cant: with_source use_effect_state_target_as_source",
            "return false"
          ]
        ],
        "on_any_damage": ["if $effect.id == aftermath:", ["return 0"]]
      }
    }
  },
  "limber": {
    "name": "Limber",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "on_update": [
          "if $mon.status == par:",
          ["log_activate: with_target", "cure_status: $mon"]
        ],
        "on_set_status": [
          "if $status.id != par:",
          ["return"],
          "if $effect.is_move and !$effect.is_move_secondary:",
          ["log_immune: $target from_effect"],
          "return false"
        ]
      }
    }
  },
  "sandveil": {
    "name": "Sand Veil",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "on_immunity": ["if $effect.id == sandstormweather:", ["return false"]],
        "on_modify_accuracy": [
          "if $field.weather == sandstormweather:",
          ["return $acc * 4/5"]
        ]
      }
    }
  },
  "static": {
    "name": "Static",
    "flags": [],
    "effect": {
      "callbacks": {
        "on_damaging_hit": [
          "if func_call(move_makes_contact: $move) and func_call(chance: 3 10):",
          ["set_status: $source par use_target_as_source"]
        ]
      }
    }
  },
  "voltabsorb": {
    "name": "Volt Absorb",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "on_try_hit": [
          "if $target != $source and $move.type == electric:",
          [
            "if func_call(heal: $target expr($target.base_max_hp / 4) use_target_as_source) == 0:",
            ["log_immune: $target from_effect"],
            "return stop"
          ]
        ]
      }
    }
  },
  "waterabsorb": {
    "name": "Water Absorb",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "on_try_hit": [
          "if $target != $source and $move.type == electric:",
          [
            "if func_call(heal: $target expr($target.base_max_hp / 4)) > 0:",
            ["log_immune: $target from_effect"],
            "return stop"
          ]
        ]
      }
    }
  },
  "oblivious": {
    "name": "Oblivious",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "on_update": [
          "if func_call(has_volatile: $mon attract):",
          ["log_activate: with_target", "remove_volatile: $mon attract"],
          "if func_call(has_volatile: $mon taunt):",
          ["log_activate: with_target", "remove_volatile: $mon taunt"]
        ],
        "on_immunity": ["if $effect.id == attract:", ["return false"]],
        "on_try_hit": [
          "if [attract, captivate, taunt] has $move.id:",
          ["log_immune: $target from_effect", "return stop"]
        ],
        "on_try_boost": [
          "if $effect.id == intimidate and $boosts.atk != 0:",
          [
            "$boosts.atk = 0",
            "log_fail_unboost: $target from_effect atk",
            "return $boosts"
          ]
        ]
      }
    }
  },
  "cloudnine": {
    "name": "Cloud Nine",
    "flags": [],
    "effect": {
      "callbacks": {
        "suppress_field_weather": ["return true"],
        "on_switch_in": ["$effect_state.switching_in = true"],
        "on_start": [
          "if $effect_state.switching_in:",
          ["log_ability", "$effect_state.switching_in = false"],
          "run_event_for_each_active_mon: WeatherChange"
        ],
        "on_end": ["run_event_for_each_active_mon: WeatherChange"]
      }
    }
  },
  "compoundeyes": {
    "name": "Compound Eyes",
    "flags": [],
    "effect": {
      "callbacks": {
        "on_source_modify_accuracy": ["return $acc * 13/10"]
      }
    }
  },
  "insomnia": {
    "name": "Insomnia",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "on_update": [
          "if $mon.status == slp:",
          ["log_activate: with_target", "cure_status: $mon"]
        ],
        "on_set_status": [
          "if $status.id != slp:",
          ["return"],
          "if $effect.is_move and !$effect.is_move_secondary:",
          ["log_immune: $target from_effect"],
          "return false"
        ]
      }
    }
  },
  "colorchange": {
    "name": "Color Change",
    "flags": [],
    "effect": {
      "callbacks": {
        "on_after_move_secondary_effects": [
          "if $target.hp == 0:",
          ["return"],
          "$type = $move.type",
          "if $target.active and $move.category != status and !func_call(has_type: $target $type):",
          ["set_types: $target $type"]
        ]
      }
    }
  },
  "immunity": {
    "name": "Immunity",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "on_update": [
          "if $mon.status == psn or $mon.status == tox:",
          ["log_activate: with_target", "cure_status: $mon"]
        ],
        "on_set_status": [
          "if $status.id != psn and $status.id != tox:",
          ["return"],
          "if $effect.is_move and !$effect.is_move_secondary:",
          ["log_immune: $target from_effect"],
          "return false"
        ]
      }
    }
  },
  "flashfire": {
    "name": "Flash Fire",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "on_try_hit": [
          "if $target == $source or $move.type != fire:",
          ["return"],
          "$move.accuracy = exempt",
          "if !func_call(add_volatile: $target $this.id):",
          ["log_immune: $target from_effect"],
          "return stop"
        ],
        "on_end": ["remove_volatile: $target $this.id"]
      }
    },
    "condition": {
      "no_copy": true,
      "callbacks": {
        "on_start": ["log_start"],
        "on_end": ["log_end: silent"],
        "on_modify_atk": [
          "if $effect.is_defined and $effect.type == fire and func_call(has_ability: $target $this.id):",
          ["return $atk * 3/2"]
        ],
        "on_modify_spa": [
          "if $effect.is_defined and $effect.type == fire and func_call(has_ability: $target $this.id):",
          ["return $spa * 3/2"]
        ]
      }
    }
  },
  "shielddust": {
    "name": "Shield Dust",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "on_modify_secondary_effects": [
          "$filtered = []",
          "foreach $secondary in $secondary_effects:",
          [
            "if $secondary.user.is_defined:",
            ["$filtered = func_call(append: $filtered $secondary)"]
          ],
          "return $filtered"
        ]
      }
    }
  },
  "owntempo": {
    "name": "Own Tempo",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "on_update": [
          "if func_call(has_volatile: $mon confusion):",
          ["log_activate: with_target", "remove_volatile: $mon confusion"]
        ],
        "on_immunity": ["if $effect.id == confusion:", ["return false"]],
        "on_add_volatile": ["if $volatile == confusion:", ["return false"]],
        "on_try_hit": [
          "if $move.hit_effect.volatile_status == confusion:",
          ["log_immune: $target from_effect", "return stop"]
        ],
        "on_try_boost": [
          "if $effect.id == intimidate and $boosts.atk != 0:",
          [
            "$boosts.atk = 0",
            "log_fail_unboost: $target from_effect atk",
            "return $boosts"
          ]
        ]
      }
    }
  },
  "suctioncups": {
    "name": "Suction Cups",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "on_drag_out": {
          "order": 1,
          "program": ["log_activate: with_target", "return false"]
        }
      }
    }
  },
  "intimidate": {
    "name": "Intimidate",
    "flags": [],
    "effect": {
      "callbacks": {
        "on_start": [
          "$activated = false",
          "foreach $mon in func_call(adjacent_foes: $target):",
          [
            "if !$activated:",
            ["log_activate: with_target", "$activated = true"],
            "boost: $mon 'atk:-1' use_target_as_source"
          ]
        ]
      }
    }
  },
  "shadowtag": {
    "name": "Shadow Tag",
    "flags": [],
    "effect": {
      "callbacks": {
        "on_foe_trap_mon": [
          "if !func_call(has_ability: $mon $this.id) and func_call(is_adjacent: $mon $effect_state.target):",
          ["return true"]
        ]
      }
    }
  },
  "roughskin": {
    "name": "Rough Skin",
    "flags": [],
    "effect": {
      "callbacks": {
        "on_damaging_hit": {
          "order": 1,
          "program": [
            "if func_call(move_makes_contact: $move):",
            [
              "damage: $source expr($source.base_max_hp / 8) use_target_as_source"
            ]
          ]
        }
      }
    }
  },
  "wonderguard": {
    "name": "Wonder Guard",
    "flags": ["Breakable", "NoRolePlay", "NoSkillSwap"],
    "effect": {
      "callbacks": {
        "on_try_hit": [
          "if $target == $source or $move.category == status or $move.typeless or $move.id == struggle:",
          ["return"],
          "if func_call(type_effectiveness: $move $target) <= 0:",
          ["log_immune: $target from_effect", "return stop"]
        ]
      }
    }
  },
  "levitate": {
    "name": "Levitate",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "is_grounded": ["return false"]
      }
    }
  },
  "effectspore": {
    "name": "Effect Spore",
    "flags": [],
    "effect": {
      "callbacks": {
        "on_damaging_hit": [
          "if !func_call(move_makes_contact: $move) or $source.status.is_defined or func_call(check_immunity: $source powder):",
          ["return"],
          "$rand = func_call(random: 100)",
          "if $rand < 11:",
          ["$status = slp"],
          "else if $rand < 21:",
          ["$status = par"],
          "else if $rand < 30:",
          ["$status = psn"],
          "if $status.is_defined:",
          ["set_status: $source $status use_target_as_source"]
        ]
      }
    }
  },
  "synchronize": {
    "name": "Synchronize",
    "flags": [],
    "effect": {
      "callbacks": {
        "on_after_set_status": [
          "if !$source or $source == $target:",
          ["return"],
          "if $status.id == slp or $status.id == frz:",
          ["return"],
          "log_activate: with_target",
          "set_status: $source $status.id use_target_as_source"
        ]
      }
    }
  },
  "clearbody": {
    "name": "Clear Body",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "on_try_boost": [
          "if $target == $source:",
          ["return"],
          "$cleared = []",
          "foreach $boost in func_call(boostable_stats):",
          [
            "if func_call(get_boost: $boosts $boost) < 0:",
            [
              "$boosts = func_call(set_boost: $boosts $boost 0)",
              "$cleared = func_call(append: $cleared $boost)"
            ]
          ],
          "if !$cleared.is_empty and !$effect.is_move_secondary:",
          ["log_fail_unboost: $target from_effect $cleared"],
          "return $boosts"
        ]
      }
    }
  },
  "naturalcure": { "name": "Natural Cure", "flags": [] },
  "lightningrod": {
    "name": "Lightning Rod",
    "flags": ["Breakable"],
    "effect": {
      "callbacks": {
        "on_try_hit": [
          "if $target == $source or $move.type != electric:",
          ["return"],
          "if !func_call(boost: $target 'spa:1' use_target_as_source):",
          ["log_immune: $target from_effect"],
          "return stop"
        ],
        "on_any_redirect_target": [
          "if $move.type != electric or func_call(move_has_flag: $move pledgecombo):",
          ["return"],
          "$redirect = $move.target",
          "if [randomnormal, adjacentfoe] has $move.target:",
          ["$redirect = normal"],
          "if !func_call(valid_target: $user $effect_state.target $redirect):",
          ["return"],
          "log_activate: with_target",
          "return $effect_state.target"
        ]
      }
    }
  },
  "serenegrace": {
    "name": "Serene Grace",
    "flags": [],
    "effect": {
      "callbacks": {
        "on_use_move": {
          "priority": -1,
          "program": []
        }
      }
    }
  },
  "swiftswim": {
    "name": "Swift Swim",
    "flags": [],
    "effect": {
      "callbacks": {
        "on_modify_spe": [
          "$weather = $target.effective_weather",
          "if $weather.is_defined and $weather.is_raining:",
          ["return $spe * 2"]
        ]
      }
    }
  },
  "chlorophyll": {
    "name": "Chlorophyll",
    "flags": [],
    "effect": {
      "callbacks": {
        "on_modify_spe": [
          "$weather = $target.effective_weather",
          "if $weather.is_defined and $weather.is_sunny:",
          ["return $spe * 2"]
        ]
      }
    }
  },
  "illuminate": { "name": "Illuminate", "flags": ["Breakable"] },
  "trace": { "name": "Trace", "flags": ["NoRolePlay"] },
  "hugepower": { "name": "Huge Power", "flags": [] },
  "poisonpoint": { "name": "Poison Point", "flags": [] },
  "innerfocus": { "name": "Inner Focus", "flags": [] },
  "magmaarmor": { "name": "Magma Armor", "flags": [] },
  "waterveil": { "name": "Water Veil", "flags": [] },
  "magnetpull": { "name": "Magnet Pull", "flags": [] },
  "soundproof": {
    "name": "Soundproof",
    "flags": [],
    "effect": {
      "callbacks": {
        "is_soundproof": ["return true"],
        "on_try_hit": [
          "if $target != $source and func_call(move_has_flag: $move sound):",
          ["log_immune: $target from_effect", "return false"]
        ]
      }
    }
  },
  "raindish": { "name": "Rain Dish", "flags": [] },
  "sandstream": {
    "name": "Sand Stream",
    "flags": [],
    "effect": {
      "callbacks": {
        "on_start": ["set_weather: sandstormweather use_target_as_source"]
      }
    }
  },
  "pressure": { "name": "Pressure", "flags": [] },
  "thickfat": { "name": "Thick Fat", "flags": [] },
  "earlybird": { "name": "Early Bird", "flags": [] },
  "flamebody": { "name": "Flame Body", "flags": [] },
  "runaway": { "name": "Run Away", "flags": [] },
  "keeneye": { "name": "Keen Eye", "flags": [] },
  "hypercutter": { "name": "Hyper Cutter", "flags": [] },
  "pickup": { "name": "Pickup", "flags": [] },
  "truant": { "name": "Truant", "flags": [] },
  "hustle": { "name": "Hustle", "flags": [] },
  "cutecharm": { "name": "Cute Charm", "flags": [] },
  "plus": { "name": "Plus", "flags": [] },
  "minus": { "name": "Minus", "flags": [] },
  "forecast": { "name": "Forecast", "flags": ["NoRolePlay"] },
  "stickyhold": { "name": "Sticky Hold", "flags": [] },
  "shedskin": { "name": "Shed Skin", "flags": [] },
  "guts": { "name": "Guts", "flags": [] },
  "marvelscale": { "name": "Marvel Scale", "flags": [] },
  "liquidooze": { "name": "Liquid Ooze", "flags": [] },
  "overgrow": { "name": "Overgrow", "flags": [] },
  "blaze": { "name": "Blaze", "flags": [] },
  "torrent": { "name": "Torrent", "flags": [] },
  "swarm": { "name": "Swarm", "flags": [] },
  "rockhead": { "name": "Rock Head", "flags": [] },
  "drought": {
    "name": "Drought",
    "flags": [],
    "effect": {
      "callbacks": {
        "on_start": ["set_weather: harshsunlight use_target_as_source"]
      }
    }
  },
  "arenatrap": { "name": "Arena Trap", "flags": [] },
  "vitalspirit": { "name": "Vital Spirit", "flags": [] },
  "whitesmoke": { "name": "White Smoke", "flags": [] },
  "purepower": { "name": "Pure Power", "flags": [] },
  "shellarmor": { "name": "Shell Armor", "flags": [] },
  "airlock": {
    "name": "Air Lock",
    "flags": [],
    "effect": {
      "callbacks": {
        "suppress_field_weather": ["return true"],
        "on_switch_in": "$effect_state.switching_in = true",
        "on_start": ["if $effect_state.switching_in:", ["log_ability"]]
      }
    }
  }
}
