use std::fmt::{
    Arguments,
    Display,
};

use thiserror::Error;

use crate::error::{
    context::ContextError,
    general_error,
    not_found_error,
};

#[derive(Error, Debug)]
#[error(transparent)]
#[repr(transparent)]
struct ErrorInternal(anyhow::Error);

impl ErrorInternal {
    #[track_caller]
    fn wrap<M>(error: anyhow::Error, message: M) -> Self
    where
        M: Display,
    {
        Self(error.context(ContextError::new(message)))
    }
}

impl AsRef<anyhow::Error> for ErrorInternal {
    fn as_ref(&self) -> &anyhow::Error {
        &self.0
    }
}

impl From<anyhow::Error> for ErrorInternal {
    #[track_caller]
    fn from(value: anyhow::Error) -> Self {
        Self(value)
    }
}

/// An error generated by the battler library.
///
/// Errors are intended to be generic (using [`anyhow::Error`]) and wrappable (using the
/// [`WrapError`] and [`WrapResultError`] traits).
#[derive(Error, Debug)]
#[error(transparent)]
#[repr(transparent)]
pub struct Error(ErrorInternal);

impl Error {
    /// Wraps an error with the given message and source location.
    #[track_caller]
    pub fn wrap<M>(error: anyhow::Error, message: M) -> Self
    where
        M: Display,
    {
        Self(ErrorInternal::wrap(error, message))
    }

    /// Creates a string of the full description, which is all error chained together.
    pub fn full_description(&self) -> String {
        format!("{self:#}")
    }
}

impl AsRef<anyhow::Error> for Error {
    fn as_ref(&self) -> &anyhow::Error {
        self.0.as_ref()
    }
}

impl From<anyhow::Error> for Error {
    fn from(value: anyhow::Error) -> Self {
        Self(ErrorInternal::from(value))
    }
}

/// Wraps an error into [`Error`], optionally providing additional context.
pub trait WrapError {
    /// Wraps the object into an [`Error`].
    #[track_caller]
    fn wrap_error(self) -> Error;

    /// Wraps the object into an [`Error`], with an additional message.
    #[track_caller]
    fn wrap_error_with_message<M>(self, message: M) -> Error
    where
        M: Display;
}

impl<E> WrapError for E
where
    E: Into<anyhow::Error>,
{
    #[track_caller]
    fn wrap_error(self) -> Error {
        Error::from(self.into())
    }

    #[track_caller]
    fn wrap_error_with_message<M>(self, message: M) -> Error
    where
        M: Display,
    {
        Error::wrap(self.into(), message)
    }
}

/// Wraps an object into a result producing an [`Error`], optionally providing additional
/// context.
pub trait WrapResultError<T> {
    /// Wraps the object into a [`Result<T, Error>`].
    #[track_caller]
    fn wrap_error(self) -> Result<T, Error>;

    /// Wraps the object into a [`Result<T, Error>`], with an additional message.
    #[track_caller]
    fn wrap_error_with_message<M>(self, message: M) -> Result<T, Error>
    where
        M: Display;

    /// Wraps the object into a [`Result<T, Error>`], with an additional formatted message.
    #[track_caller]
    fn wrap_error_with_format<'a>(self, args: Arguments<'a>) -> Result<T, Error>;
}

impl<T, E> WrapResultError<T> for Result<T, E>
where
    E: WrapError,
{
    #[track_caller]
    fn wrap_error(self) -> Result<T, Error> {
        match self {
            Ok(val) => Ok(val),
            Err(error) => Err(error.wrap_error()),
        }
    }

    #[track_caller]
    fn wrap_error_with_message<M>(self, message: M) -> Result<T, Error>
    where
        M: Display,
    {
        match self {
            Ok(val) => Ok(val),
            Err(error) => Err(error.wrap_error_with_message(message)),
        }
    }

    #[track_caller]
    fn wrap_error_with_format<'a>(self, args: Arguments<'a>) -> Result<T, Error> {
        match self {
            Ok(val) => Ok(val),
            Err(error) => Err(error.wrap_error_with_message(format!("{args}"))),
        }
    }
}

/// Wraps an [`Option`] into a result producing an [`Error`].
pub trait WrapOptionError<T> {
    /// Wraps the object into a [`Result<T, Error>`].
    #[track_caller]
    fn wrap_expectation<M>(self, message: M) -> Result<T, Error>
    where
        M: Display;

    /// Wraps the object into a [`Result<T, Error>`], with a formatted message.
    #[track_caller]
    fn wrap_expectation_with_format<'a>(self, args: Arguments<'a>) -> Result<T, Error>;

    /// Wraps the object into a [`Result<T, Error>`], with a
    /// [`NotFoundError`][`crate::error::NotFoundError`] behind the scenes.
    #[track_caller]
    fn wrap_not_found_error<M>(self, message: M) -> Result<T, Error>
    where
        M: Display;

    /// Wraps the object into a [`Result<T, Error>`], with a
    /// [`NotFoundError`][`crate::error::NotFoundError`] behind the scenes, with a formatted
    /// message.
    #[track_caller]
    fn wrap_not_found_error_with_format<'a>(self, args: Arguments<'a>) -> Result<T, Error>;
}

impl<T> WrapOptionError<T> for Option<T> {
    fn wrap_expectation<M>(self, message: M) -> Result<T, Error>
    where
        M: Display,
    {
        match self {
            Some(val) => Ok(val),
            None => Err(general_error(message)),
        }
    }

    #[track_caller]
    fn wrap_expectation_with_format<'a>(self, args: Arguments<'a>) -> Result<T, Error> {
        match self {
            Some(val) => Ok(val),
            None => Err(general_error(format!("{args}"))),
        }
    }

    #[track_caller]
    fn wrap_not_found_error<M>(self, message: M) -> Result<T, Error>
    where
        M: Display,
    {
        match self {
            Some(val) => Ok(val),
            None => Err(not_found_error(message)),
        }
    }

    #[track_caller]
    fn wrap_not_found_error_with_format<'a>(self, args: Arguments<'a>) -> Result<T, Error> {
        match self {
            Some(val) => Ok(val),
            None => Err(not_found_error(format!("{args}"))),
        }
    }
}
