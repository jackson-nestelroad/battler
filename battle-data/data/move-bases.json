{
  "breakprotectmovebase": {
    "name": "Break Protect Move Base",
    "condition_type": "Built-in",
    "condition": {
      "callbacks": {
        "on_try_hit": ["add_volatile: $target breakprotect"]
      }
    }
  },
  "chargemovebase": {
    "name": "Charge Move Base",
    "condition_type": "Built-in",
    "condition": {
      "callbacks": {
        "on_try_use_move": [
          "if func_call(remove_volatile: $user $this.id):",
          ["return"],
          "log_prepare_move",
          "$charge_move = func_call(run_event_on_move: ChargeMove)",
          "if $charge_move.is_defined and !$charge_move:",
          [
            "do_not_animate_last_move",
            "log_animate_move: $user $this.name $target",
            "return"
          ],
          "if !func_call(run_event: ChargeMove):",
          [
            "do_not_animate_last_move",
            "log_animate_move: $user $this.name $target",
            "return"
          ],
          "add_volatile: $user twoturnmove link",
          "return stop"
        ]
      }
    }
  },
  "weakenthroughprotectionmovebase": {
    "name": "Weaken Through Protection Move Base",
    "condition_type": "Built-in",
    "condition": {
      "callbacks": {
        "on_source_modify_damage": [
          "if func_call(move_has_flag: $move weakenthroughprotection):",
          [
            "log_custom_effect: protectweaken no_effect with_target use_source",
            "return $damage / 4"
          ]
        ]
      }
    }
  },
  "defogmovebase": {
    "name": "Defog Move Base",
    "condition_type": "Built-in",
    "condition": {
      "callbacks": {
        "on_hit": [
          "$remove_from_target_side = [reflect, lightscreen, auroraveil, safeguard, mist]",
          "$remove_from_both_sides = [spikes, toxicspikes, stealthrock, stickyweb, gmaxsteelsurge]",
          "$success = false",
          "$target_side = $target.side",
          "if func_call(value_from_local_data: use_source_foe_side) == 'true':",
          ["$target_side = $source.foe_side"],
          "foreach $condition in $remove_from_target_side:",
          [
            "if func_call(remove_side_condition: $target_side $condition):",
            ["$success = true"]
          ],
          "foreach $condition in $remove_from_both_sides:",
          [
            "foreach $side in $field.sides:",
            [
              "if func_call(remove_side_condition: $side $condition):",
              ["$success = true"]
            ]
          ],
          "clear_terrain",
          "return $success"
        ]
      }
    }
  },
  "pledgemovebase": {
    "name": "Pledge Move Base",
    "condition_type": "Built-in",
    "condition": {
      "callbacks": {
        "on_prepare_hit": [
          "for $action in func_call(pending_move_actions_this_turn):",
          [
            "if !$action.mon.active or $action.mon.fainted:",
            ["continue"],
            "$other_move_id = $action.effective_id",
            "if func_call(is_ally: $source $action.mon) and $other_move_id != $this.id and func_call(move_has_flag: $other_move_id pledgecombo):",
            [
              "prioritize_move: $action.mon",
              "log_waiting: $source $action.mon",
              "return stop"
            ]
          ]
        ],
        "on_move_base_power": [
          "if $move.source_effect.is_defined and $move.source_effect.id != $this.id and func_call(move_has_flag: $move.source_effect pledgecombo):",
          ["log_combine", "return 150"]
        ]
      }
    }
  }
}
